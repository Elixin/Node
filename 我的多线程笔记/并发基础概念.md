# 上下文切换

> CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）

每个任务会在不同的时间片上运行,而每个任务在时间片上执行的时间十分短暂,执行完毕后先保存这个任务的状态,再去执行下一个任务,方便下一次访问这个任务,从保存到加载为上下文切换 而上下文切换会影响多线程执行速度

## 如何减少上下文切换

- 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
- CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
- 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

--------------------------------------

# 死锁

## 产生死锁的原因

> 线程A执行锁A等待执行锁B 
>
> 线程B执行锁B等待执行锁A

线程AB都在等待对方释放已经占用的锁,造成死锁

## 避免死锁的常用方法

- 避免同一线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

# Java并发机制

### volatile

**作用:** 锁定共享变量

保证变量在内存中的可见性,可见性的含义是一个线程修改共享变量能够被另一个线程检测到并强制刷新,而相对synchronized来说,合理的使用volatile能够降低使用成本,因为volatile不需要加锁也就不需要进行上下文切换

### synchronized (重量级锁)

作用于 普通同步方法,静态同步方法,代码块

> 实例对象是通过New关键字构建的对象
>
> Class对象是一个继承Object的特殊类,他是一个用来表示类的类

- 普通同步方法(非静态方法) 调用当前实例对象作为锁
- 静态同步方法 调用当前类的Class对象作为锁
- 同步代码块 锁是括号中配置的对象

# 锁

在JDK SE 1.6版本中锁分为4种状态

从轻到重:无锁状态,偏向锁状态,轻量级锁状态,重量级锁状态

而这几种锁的状态回随着竞争状态逐渐升级,切不可降级

## 偏向锁

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

如果测试成功，表示线程已经获得了锁。

如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）

如果没有设置，则使用CAS竞争锁；

如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

![偏向锁状态切换图](https://staticcdn1-5.umiwi.com/pcebook/online/img/202006/0315911593063831907416485414571365066758.jpg)

换句话说,偏向锁状态回检测线程的Mark Word中是否获取偏向锁,如果获取偏向锁则认为线程已经获取到锁,没有这进行CAS竞争锁,而当有线程开始竞争偏向锁的时,持有偏向锁的线程才会释放锁

## 轻量级锁

加锁

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

解锁

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

![轻量级锁及膨胀](https://staticcdn1-5.umiwi.com/pcebook/online/img/202006/0315911593064040919201263317295594135326.jpg)

